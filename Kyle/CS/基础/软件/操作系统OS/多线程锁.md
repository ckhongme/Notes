多线程最大的问题是线程安全；
### 数据一致性问题
多个线程不能同时对同一个内存进行数据写入；
### 多线程锁 lock
保证同一时间某个对象只有一个线程在访问；

lock 语句获取给定对象的互斥锁，执行语句块，然后释放 lock；（lock是语法糖，是通过Monitor来实现的）
lock锁定的对象，应该是 静态的的引用类型（string类型除外）；

保证lock的对象在外部无法修改才有意义，如果lock的对象在外部改变了，对其他线程就会畅通无阻，失去了lock的意义；


**互斥锁：**

对共享资源的访问必须是顺序的，也就是说当多个线程对共享资源访问的时候，只能有一个线程可以获得该共享资源的锁

**死锁：**

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。尽管死锁很少发生，但一旦发生就会造成应用的停止响应（就像夫妻吵架，都等着对方先道歉，就会造成死锁）

**活锁：**

是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。

悲观锁（先上锁再访问）：

每次去拿数据时都认为别人会修改；

lock块内的代码当前只被一个线程执行

通常应避免锁定public类型，否则实例将超出代码的控制范围；

代码区是共享的，如果几个线程同时执行一个函数，就可能导致数据的混乱；

不能锁定值类型的原因是，当这个值类型传递到另一个线程的时候，会创建一个副本，锁定的也不再是同一个对象了。

不要锁定字符串的原因是，字符串在CLR中会暂存在 内存中，如果有两个变量被分配了相同的字符串内容，那么这两个引用会指向同一块内存，实际锁定也就是同一个对象，这就会导致整个应用程序的阻塞。

锁可以阻止其它线程执行锁块(lock(o){})中的代码，当锁定时，其它线程必须等待锁中的线程执行完成并释放锁。但是这可能会给程序带来性能影响。

锁不太适合I/O场景，例如文件I/O，繁杂的计算或者操作比较持久的过程，会给程序带来很大的性能损失。

在锁中摆脱昂贵的计算；