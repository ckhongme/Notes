[[多线程]]最大的问题是线程安全；
数据一致性问题：多个线程不能同时对同一个内存进行数据写入；
线程锁可以保证同一时间某个对象只有一个[[线程]]在访问；

- [[互斥锁]]
- [[死锁]]
- [[活锁]]
- [[悲观锁]]


锁可以阻止其它线程执行锁块(lock(o){})中的代码，当锁定时，其它线程必须等待锁中的线程执行完成并释放锁。但是这可能会给程序带来性能影响。
锁不太适合I/O场景，例如文件I/O，繁杂的计算或者操作比较持久的过程，会给程序带来很大的性能损失。

lock 语句获取给定对象的互斥锁，执行语句块，然后释放 lock；（lock是语法糖，是通过Monitor来实现的）
lock锁定的对象，应该是 静态的的引用类型（string类型除外）；
保证lock的对象在外部无法修改才有意义，如果lock的对象在外部改变了，对其他线程就会畅通无阻，失去了lock的意义；

lock块内的代码当前只被一个线程执行
通常应避免锁定public类型，否则实例将超出代码的控制范围；

[[代码区]]是共享的，如果几个线程同时执行一个函数，就可能导致数据的混乱；


- 不能锁定值类型的原因是，当这个值类型传递到另一个线程的时候，会创建一个副本，锁定的也不再是同一个对象了。
- 不要锁定字符串的原因是，字符串在CLR中会暂存在 内存中，如果有两个变量被分配了相同的字符串内容，那么这两个引用会指向同一块内存，实际锁定也就是同一个对象，这就会导致整个应用程序的阻塞。

## **锁保护**
当应用程序要求以先到先得的顺序锁定和锁定处的到达率高于获取率时将发生锁保护。 这两个条件的组合会导致要求锁开始进行备份。 解决此问题的一种方法是使用“不公平”锁或使用授予第一个线程访问权限的锁，以在未锁定状态中找到查找它们。 上图显示了此保护行为。 若要解决此问题，请尝试减少同步对象的争用并尝试使用不公平锁。