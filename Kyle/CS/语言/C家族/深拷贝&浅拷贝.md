#语言/cpp 
***
### 浅拷贝
简单的赋值拷贝操作；
-   带来的问题：如果属性有在堆区开辟的，析构的时候，堆区的内存会重复释放；
-   解决方法：当存在堆区数据时，自定义一个深拷贝构造函数；([[C++ 运算符#重载赋值运算符 =]])

### 深拷贝
在堆区重新申请空间，进行拷贝操作
```cpp
class Person
{
public:
	int * height;
public:
	Person(int height)
	{
		height = new int(height);
	}
	//深拷贝
	Person(const Person &p)  
	{
		//编译器默认的写法：height = p.height； （没有重新申请空间）
		height = new int(*p.height);
	}
	//析构函数
	~Person()   
	{
		if(height != null)
		{
			delete height;
			height = null;
		}
	}
}
```
