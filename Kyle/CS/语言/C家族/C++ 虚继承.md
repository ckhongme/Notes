#语言/cpp 
***
继承前加virtual关键字；
可以解决菱形继承问题：
- 命名冲突（二义性问题）
	  B和C都继承了A的变量a，此时D继承自B和C，直接访问a就会出现命名冲突，需要通过作用域访问，B::a，C::a
- 冗余数据问题（子类继承两份相同的数据，导致资源浪费）

**虚函数**：函数前加virtual关键字；
**重写**：函数返回值类型，函数名，参数列表完全一致；（子类的函数与父类的虚函数）

---
### C++多态的原理剖析

父类和子类的内部都存在一个虚函数指针vfptr；（v-virtual，f-function，ptr-pointer）
vfptr指向一个虚函数表vftable，表内记录虚函数的地址：
-   父类的表内记录自身虚函数的地址；
-   当没有重写时，子类的表内记录父类虚函数的地址；当发生重写时，子类重写函数的地址会覆盖父类虚函数的地址；

### 纯虚函数
父类中虚函数的实现大多数情况下是用不到的，主要调用的是子类重写的内容，因此可以改成纯虚函数；

```cpp
virtual 返回值类型 函数名(参数列表) = 0;
```

### 抽象类
含有纯虚函数；
子类必须重写父类的纯虚函数，否者也属于抽象类；

### 虚析构和纯虚析构

父类指针在析构的时候，不会调用子类的析构函数，导致子类如果有堆区属性，出现内存泄漏；

解决方法：在父类的析构函数前加上virtual，改为虚析构，或者改成纯虚析构；

```cpp
void test()
{
	Animal * animal = new Cat("Tom");
	animal->speak();
	//释放animal的时候，不会调用Cat的析构函数；
	delete animal;
}
```

虚析构跟纯虚析构都要有具体的函数实现；

```cpp
// 虚析构语法：
virtual ~类名(){}

// 纯虚析构语法：
virtual ~类名() = 0;
类名::~类名(){}
```

-   解决 父类指针释放子类对象 时不干净的问题；
-   如果子类没有堆区数据，可以不写虚析构或纯虚析构；
-   拥有纯虚析构函数的类也属于抽象类；