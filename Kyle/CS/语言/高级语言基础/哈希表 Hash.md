### 哈希表
也叫散列表，是根据关键码值 (Key-Value) 而直接进行访问的数据结构；一种寻址容易，插入删除也容易的数据结构；

关键码值会映射到表中的一个位置，以提高查找速度；

哈希表设计了一个映射关系f(key)= address，根据key来计算存储地址address，这样可以1次查找，f既是存储数据过程中用来指引数据存储到什么位置的函数，也是将来查找这个位置的算法，叫做哈希算法

提高数据的查找效率；
**如何提高查找效率？**
直接根据数据的散列码和散列表的数组大小计算除余后，就得到了所在数组的位置，然后再查找链表中是否有这个数据即可；

##### Hash函数
把**任意长度的输入**，变成**固定长度的输出**；
哈希算法的本质是计算一个数字，输出的就是Hash值；
一种**压缩映射**， 不同的输入可能会散列成相同的输出；（不能从散列值来唯一的确定输入值）

### Hash冲突
当多个数据被映射到同一个地址上时，就会产生冲突；
解决冲突的方法：开放定址法、链地址法、再次哈希法、建立公共溢出区

##### 链地址法
本质就是数组+链表：底层结构是一个数组，数组中的每一项是一条链表；
当发生冲突时，将记录插入到链表中；
需要链表特性，操作简单，但需要额外的空间存储指针；


线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些












##### 散列码 hashCode
散列码是由对象导出的一个整数值。在Object中有一个hashCode方法来得到散列码；
例：String对象的散列码是对内容的计算结果；




HashMap的key是不可以重复的，保证元素唯一的依据是对象的hashCode跟equals方法






### 什么是HashSet？
基于HashMap，实现了Set接口，不允许集合中有重复元素；

HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();
HashSet不能重复存储equals相同的数据 。
equals相同，数据的散列码也就相同（hashCode必须和equals兼容）。大量相同的数据将存放在同一个散列单元所指向的链表中，造成严重的散列冲突，对查找效率是灾难性的；

当我们提到HashSet时，第一件事就是在将对象存储在HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有
储存相同的对象；

HashMap | HashSet
--|--
实现Map接口|实现Set接口
存储键值对|仅存储对象
使用Key计算hashCode|使用成员对象来计算hashcode











