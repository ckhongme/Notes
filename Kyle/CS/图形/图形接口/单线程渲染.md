一般情况下，主线程(CPU1)在游戏每一帧运行过程中，
先执行Update（在这里做大量的逻辑更新，例如AI、碰撞检测和动画更新等）
然后执行Render（在这里做[[渲染]]相关的指令调用）

在渲染时，主线程需要调用图形API更新渲染状态，例如设置shader、纹理、矩阵和alpha融合等，然后再执行[[Draw Call]]；

图形API的调用是与驱动层交互的
而驱动层维护着所有的渲染状态，
这些API的调用有可能会触发驱动层的渲染状态的改变，从而发生卡顿；

由于驱动层的状态对于上层调用是透明的，因此卡顿是否会发生以及卡顿发生的时间长短对于API的调用者(CPU1)来说都是未知的；
***
### 卡顿
调用次数较多的渲染指令：
- 提交渲染
- Clear
- 编译Shader
- 更新VBO
- 绘制VBO

提交渲染(OpenGL ES的API：eglSwapBuffers)会导致驱动层中缓存的渲染指令立即执行，此时CPU被阻塞。如果在提交渲染时驱动层缓存了大量的指令，CPU就会被阻塞很长时间。
##### 解决方案1：伪多线程渲染
将渲染部分抽离出来，放到其它的CPU中，以减少主线程卡顿；
##### 解决方案2：真正的[[多线程渲染]]
多个渲染线程；
***
https://zhuanlan.zhihu.com/p/44116722